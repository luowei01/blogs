@[TOC](A_star算法)
# 1.算法基本原理
## 广度优先搜索算法
```
def breadth_first_seach(graph, start, goal):
    """
    # 广度优先搜索，向四周平等的探索，利用队列存放待探索的点,集合存放已探索的点，
    用字典的键值记录来时的路径，便于溯源，可以找到最短路径
    :param graph: 输入解析出来的图，节点和边组成
    :param start:  起点
    :param goal: 终点
    :return: 返回起点到终点的最短路径
    """
    frontier = Queue()
    frontier.put(start)
    # reached = set()  # 用集合存放到达的方块
    # reached.add(start)
    came_from = dict()  # 用字典的键值记录来时的路径
    came_from[start] = None  # 显然起点来时的路径为空
    while not frontier.empty():
        current = frontier.get()
        if current == goal:
            break
        for next in graph.neighbors(current):
            if next not in came_from:
                frontier.put(next)
                came_from[next] = current
    # 跟随指向从终点回到起点
    current = goal
    path = []
    while current != start:
        path.append(current)
        current = came_from[current]
    path.append(start)
    path.reverse()  # 将顺序正过来，终点到起点，变为起点到终点
    return path
```
## Dijkstra算法
相比广度优先搜索，加入优先队列、cost_so_far来考虑起点到当前节点的代价
```
def dijkstra_seach(graph, start, goal):
    """
    # Dijkstra算法,考虑了成本cost_so_far,使用优先队列保存要探索的点，改变了探索边界扩展的方式
    但还是沿各个方向扩展，可以绕开部分成本多的区域，这是和广度优先搜索四周均匀扩展的区别
    两者都找到了最短路径。
    :param graph: 输入解析出来的图，节点和边组成
    :param start:  起点
    :param goal: 终点
    :return: 返回起点到终点的最短路径
    """
    frontier = PriorityQueue()
    frontier.put(start, 0)
    came_from = dict()  # 用字典的键值记录来时的路径
    came_from[start] = None  # 显然起点来时的路径为空
    cost_so_far = dict()
    cost_so_far[start] = 0

    while not frontier.empty():
        current = frontier.get()
        if current == goal:
            break
        for next in graph.neighbors(current):
            new_cost = cost_so_far[current] + graph.cost(current,next)
            if next not in came_from or new_cost < cost_so_far[next]:
                cost_so_far[next] = new_cost
                priority = new_cost
                frontier.put(next,priority)
                came_from[next] = current
    # 跟随指向从终点回到起点
    current = goal
    path = []
    while current != start:
        path.append(current)
        current = came_from[current]
    path.append(start)
    path.reverse()  # 将顺序正过来，终点到起点，变为起点到终点
    return path,cost_so_far
```
## Greedy_Best_First算法
相比广度优先搜索，加入优先队列、priority，定义了一个函数来考虑和评估当前节点到终点的代价
```
#定义一个曼哈顿距离作为预测中间节点到终点的代价函数
def heuristic(a, b):
    return abs(a.x - b.x) + abs(a.y - b.y)


#贪心搜索算法，算法会沿着一个方向探索，速度块，但不能找到最短路径
def Greedy_Best_First_Search(graph, start, goal):
    """
    #找出的路径不是最短的。因此，当障碍物不多，但路径不好时，该算法运行得更快。
    :param graph: 输入解析出来的图，节点和边组成
    :param start:  起点
    :param goal: 终点
    :return: 返回起点到终点的最短路径
    """
    frontier = PriorityQueue()
    frontier.put(start, 0)
    came_from = dict()  # 用字典的键值记录来时的路径
    came_from[start] = None  # 显然起点来时的路径为空

    while not frontier.empty():
        current = frontier.get()
        if current == goal:
            break
        for next in graph.neighbors(current):
            if next not in came_from:
                priority = heuristic(goal, next)
                frontier.put(next, priority)
                came_from[next] = current
    # 跟随指向从终点回到起点
    current = goal
    path = []
    while current != start:
        path.append(current)
        current = came_from[current]
    path.append(start)
    path.reverse()  # 将顺序正过来，终点到起点，变为起点到终点
    return path
   ```
## A*算法
两者结合，起点到当前节点、当前节点到终点的代价都考虑，只要使用的启发式算法不高估距离，一定是最短路径。
```
# 定义一个曼哈顿距离作为预测中间节点到终点的代价函数
def heuristic(a, b):
    return abs(a.x - b.x) + abs(a.y - b.y)
def a_star_search(graph, start, goal):
    """
    改进的A_star算法：
    结合Greedy_Best_First_Search和Dijkstra算法，既考虑起点到中间节点的距离，也考虑中间节点到终点的距离，是最好的方法
    :param graph:
    :param start:
    :param goal:
    :return:
    """
    frontier = PriorityQueue()  # 用优先队列存放一轮探索过的边界方块，通过方块代价自动排序，每次取出代价最低的方块。
    frontier.put(start, 0)  # 在队列里存放起点
    came_from = dict() # 从当前方块到之前方块的映射，代表路径的来向
    cost_so_far = dict()  # 从起点到当前方块的当前代价
    came_from[start] = None
    cost_so_far[start] = 0
    while not frontier.empty():
        current = frontier.get()

        if current == goal:
            break
        for next in graph.neighbors(current):
            new_cost = cost_so_far[current] + graph.cost(current, next)
            if next not in cost_so_far or new_cost < cost_so_far[next]:
                cost_so_far[next] = new_cost
                priority = new_cost + heuristic(goal, next)
                frontier.put(next, priority)
                came_from[next] = current
    # 跟随指向从终点回到起点
    current = goal
    path = []
    while current != start:
        path.append(current)
        current = came_from[current]
    path.append(start)
    path.reverse()  # 将顺序正过来，终点到起点，变为起点到终点
    return came_from, cost_so_far
```
# 2.总结
| 算法 | 搜索方向 | 考虑因素 | 是否最短路径 |应用场景|
|--      |--    |--      |--     |--     | 
|广度优先搜索  | 四周、平等  | 每个点代价相等 |是 |查找到所有位置的路径，移动成本相同|
|dijkstra |  多个方向，包含无前途的方向 |只考虑中间节点到起点的代价  | 是|查找到所有位置的路径，移动成本不同|
|Greedy_Best_First | 只搜索有希望的方向  | 只考虑中间节点到终点的代价 | 不一定|查找到一个位置的路径，可以接受不是最优|
|A* | 最短路径方向  | 起点到中点、中点到终点均考虑 |是 |查找到一个位置的最短路径|

# 3.最终实现


