```python
import torch
```

0.设置学习率


```python
learning_rate= 0.01
```

1.准备数据


```python
x = torch.rand((500,1))
y_true = 3 * x + 1
```

2.创建参数W和B


```python
w = torch.rand((1,1),requires_grad = True)
b = torch.rand((1,1),requires_grad = True)
```

3.反复训练：前向计算、反向求导、更新参数、梯度清空


```python
for i in range(10000):
    y_predict = torch.matmul(x,w)+b
    loss=(y_predict-y_true).pow(2).mean()
    loss.backward()
    w.data -=learning_rate*w.grad 
    b.data -=learning_rate*b.grad 
    print(w.data,b.data)
    w.grad.data.zero_() 
    b.grad.data.zero_()
```

    tensor([[0.0804]]) tensor([[0.2595]])
    tensor([[0.1076]]) tensor([[0.3036]])
    tensor([[0.1341]]) tensor([[0.3467]])
    tensor([[0.1601]]) tensor([[0.3886]])
    tensor([[0.1854]]) tensor([[0.4294]])
    tensor([[0.2102]]) tensor([[0.4691]])
    tensor([[0.2344]]) tensor([[0.5078]])
    tensor([[0.2580]]) tensor([[0.5455]])
    tensor([[0.2811]]) tensor([[0.5822]])
    '''
    tensor([[2.9999]]) tensor([[1.0000]])
    tensor([[2.9999]]) tensor([[1.0000]])
    tensor([[2.9999]]) tensor([[1.0000]])
    tensor([[2.9999]]) tensor([[1.0000]])
    tensor([[2.9999]]) tensor([[1.0000]])
    

4.评估模型的正确率


```python
x_test = torch.rand((500,1))
y_test_true = 3*x_test +1
with torch.no_grad():
    w.data = torch.round(w.data*1000)/1000#保留与真实值相同的位数，才能相等，实际中只能逼近，不能相等
    b.data = torch.round(b.data*1000)/1000
    y_predict = torch.matmul(x_test,w)+b
    result = f"{(y_predict==y_test_true).sum()/ 500 *100}/100"
    loss = (y_predict-y_true).pow(2).mean()
print(result,f"loss={loss}",f"w={w.data},b={b.data}")
```

    100.0/100 loss=1.4682567119598389 w=tensor([[3.]]),b=tensor([[1.]])
    
